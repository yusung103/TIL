# CPU Scheduling
> 언제 어떤 프로세스에게 CPU를 할당할지 결정하는 작업

CPU가 하나의 프로세스 작업이 끝내면 다른 프로세스 작업을 수행해야 한다. 이 때 CPU가 어떤 프로세스 작업을 수행할지 선택하는 알고리즘이 CPU Scheduling 알고리즘이다

```
**CPU 스케줄러는 언제 스케줄링 결정할까?**

1. Running(실행) → Waiting(대기) 상태

2. Running(실행) → Terminate(종료) 상태

3. Running(실행) → Ready(준비) 상태

4. Waiting(대기) → Ready(준비) 상태
```
## 비선점형 (non-preemptive), 선점형 (preemptive)
### 비선점형 (non-preemptive)
>어떤 프로세스가 CPU에 할당 받고 있으면 강제로 뺏을 수 없는 방식

- time slice가 없음
  - time slice? : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
- CPU를 사용중인 프로세스가 자율적으로 반납하는 방식 (1,2번 상태)

### 비선점형 알고리즘 종류
- FCFS (First Come First Served)
  - 가장 먼저 요청한 프로세스 순으로 CPU를 할당해주는 선착순 방식
  - Convoy effect (호위 효과)가 일어날 수 있음
    - 호위 효과: 몇 개의 시간이 오래걸리는 프로세스로 인해 OS 전체가 느려지는 현상
- SJF (Shotest Job First)
  - 실행시간이 가장 짧은 프로세스부터 실행하는 알고리즘
  - 긴 시간을 필요로 하는 프로세스가 우선순위에 밀려 실행되지 못하고 무한정 밀려 대기하는 기아 현상(Starvation) 발생 가능성
- 우선순위 (Priority)
  - 각 프로세스마다 우선순위 번호가 매겨져 있음
  - 낮은 순위의 프로세스가 실행되지 않는 기아(Starving) 현상이 발생
  - 기아현상을 해결하기 위해 노화(aging)를 사용
    - 오래된 작업의 우선순위를 높여주는 방식
  - 선점, 비선점 둘 다 사용가능ㅎ


### 선점형 (preemptive)
>어떤 프로세스가 CPU에 할당 받고 있어도 중간에 운영체제가 강제로 뺏을수 있는 방식. 알고리즘에 따라 강제로 중단시키고 CPU에 다른 프로세스를 할당

- 낮은 우선순위를 가진 프로세스보다 높은 우선순위를 가진 프로세스가 CPU를 선점하는 방식
- 처리시간이 매우 긴 프로세스의 CPU 사용 독점을 막을 수 있어 효율적인 운영(+)
- 잦은 컨텍스트 스위칭으로 오버헤드(overhead) 가 커질 수 있음
  - 오버헤드 (overhead)? : 특적 기능을 수행하는데 드는 간접적인 시간, 메모리 등 자원을 가르킴
  - ex) 10초 걸리는 기능이 간접적인 원인으로 20초가 걸렸다면 오버헤드는 10초

### 선점형 알고리즘 종류
- 라운드 로빈(Round Robin; RR)  
  - 현대 컴퓨터가 사용중인 우선순위 스케줄링.  
  - 각각의 프로세스에게 동일한 시간을 부여하여 해당 시간에만 CPU를 이용.  
  - 제시간 내에 처리하지 못하면 강제 중단 후 다음작업 수행
- SRT(Shotest Remaining Time)
  - 최단 잔여시간을 우선으로 하는 알고리즘
  - 진행중인 프로세스가 있어도 최단 잔여시간 프로세스를 위해 기존에 있던 프로세스를 sleep시키고 짧은 프로세스를 CPU에 할당시킴
  - 선점형 SJF라고도 불림